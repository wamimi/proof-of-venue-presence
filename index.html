<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFiProof - Privacy-Preserving Venue Attendance</title>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .form-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .form-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin: 10px 0;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #9fcdff;
        }

        .proof-output {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .code-block {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Monaco', monospace;
            font-size: 0.9em;
            margin: 10px 0;
            overflow-x: auto;
            border: 1px solid #333;
            white-space: pre-wrap;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üì∂ WiFiProof</h1>
            <p>Privacy-preserving venue attendance verification with cryptographic QR codes!</p>
        </header>

        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'scan')">üì± Scan QR</button>
            <button class="tab-link" onclick="openTab(event, 'generate')">üîê Generate Proof</button>
            <button class="tab-link" onclick="openTab(event, 'verify')">‚úÖ Verify Proof</button>
            <button class="tab-link" onclick="openTab(event, 'about')">‚ÑπÔ∏è About</button>
        </div>

        <div id="scan" class="tab-content active">
            <h3>üì± Step 1: Scan Venue QR Code</h3>
            <p>Scan the QR code provided by the venue to verify its authenticity and auto-fill venue details.</p>
            
            <div style="text-align: center; margin: 20px 0;">
                <button id="startScanBtn" onclick="startQRScanner()">üé• Start Camera</button>
                <button id="stopScanBtn" onclick="stopQRScanner()" disabled>‚èπÔ∏è Stop Camera</button>
                <button onclick="useTestQR()">üß™ Use Test QR Data</button>
            </div>

            <video id="videoPreview" style="width: 100%; max-width: 400px; height: 300px; border-radius: 10px; margin: 20px auto; display: none;"></video>
            <canvas id="qrCanvas" style="display: none;"></canvas>
            
            <div id="scanStatus"></div>
            
            <div id="scannedVenueInfo" style="display: none;">
                <h4>‚úÖ Verified Venue Information:</h4>
                <div style="background: #e8f5e8; padding: 15px; border-radius: 10px; margin: 15px 0;">
                    <p><strong>Venue:</strong> <span id="scannedVenueName"></span></p>
                    <p><strong>WiFi Network:</strong> <span id="scannedWifiName"></span></p>
                    <p><strong>Event ID:</strong> <span id="scannedEventId"></span></p>
                    <p><strong>Valid Window:</strong> <span id="scannedTimeWindow"></span></p>
                </div>
                <button onclick="proceedToProofGeneration()" class="button">üîê Proceed to Generate Proof</button>
            </div>
        </div>

        <div id="generate" class="tab-content">
            <h3>üîê Device Identity (Private)</h3>
            <p>Your device generates a private secret, which is never shared. It remains in your browser's local storage.</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="userSecret">User Secret</label>
                    <input type="text" id="userSecret" placeholder="e.g., 1234567890123456" readonly>
                    <small>A unique numeric secret, automatically generated and stored only in this browser.</small>
                </div>
                <div class="form-group">
                    <label for="connectionNonce">Connection Nonce</label>
                    <input type="text" id="connectionNonce" placeholder="e.g., 98765" readonly>
                    <small>A random number for this specific proof, generated each time you click.</small>
                </div>
            </div>

            <h3>Venue Information (Public)</h3>
            <p>This information is public and proves you were at the right place.</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="venueId">Venue ID</label>
                    <input type="text" id="venueId" value="2407" readonly>
                    <small>The official ID for Zanzalu, July 2024.</small>
                </div>
                <div class="form-group">
                    <label for="networkSsid">WiFi Network Name</label>
                    <input type="text" id="networkSsid" value="Aura Space" readonly>
                    <small>The name of the WiFi network at the coworking space.</small>
                </div>
            <div class="form-group" style="display: none;">
                <label for="networkSsidHash">Network SSID Hash</label>
                <input type="text" id="networkSsidHash" placeholder="Auto-generated from WiFi Name" readonly>
                <small>The cryptographic hash of the network name, used in the proof.</small>
            </div>
            <div class="form-group">
                <label for="eventId">Event ID</label>
                <input type="text" id="eventId" value="20241215" readonly>
                <small>Unique identifier for this specific event or time period.</small>
            </div>
            </div>

            <h3>‚è∞ Time Window (Public)</h3>
            <p>This proves you were here at the right time‚Äîduring this talk!</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="timeWindowStart">Talk Start Time (Unix Timestamp)</label>
                    <input type= "text" id="timeWindowStart" readonly>
                    <small>The time this ZK talk started (in EAT).</small>
                </div>
                <div class="form-group">
                    <label for="timeWindowEnd">Talk End Time (Unix Timestamp)</label>
                    <input type="text" id="timeWindowEnd" readonly>
                    <small>The time this ZK talk is scheduled to end (in EAT).</small>
                </div>
                <div class="form-group">
                    <label for="proofTimestamp">Your Proof Generation Time (Unix Timestamp)</label>
                    <input type="text" id="proofTimestamp" readonly>
                    <small>The exact time you click the generate button (in EAT).</small>
                </div>
            </div>

            <button id="generateBtn" class="button-primary">Generate Zanzalu Proof</button>
            
            <div id="status" class="status" style="display:none;"></div>
            <div id="output" class="output" style="display:none;"></div>
        </div>

        <div id="verify" class="tab-content">
            <h3>‚úÖ Verify a Zanzalu Proof</h3>
            <div class="form-group">
                <label for="proofHash">Proof Hash</label>
                <input type="text" id="proofHash" placeholder="Paste the proof hash you want to verify">
            </div>
            <button id="verifyBtn" onclick="verifyProof()" class="button-primary">Verify Proof</button>
            <div id="verifyStatus" class="status" style="display:none;"></div>
            <div id="verificationResult" class="result-box" style="margin-top: 1rem;">
                <!-- Verification result will be displayed here -->
            </div>
        </div>

        <div id="about" class="tab-content">
            <h3>üéØ What is Zanzalu Presence Proof?</h3>
            <p>
                This is a live demo of a privacy-preserving Zero-Knowledge proof system. It lets you prove you were physically present
                at the "Aura Space" coworking area in Zanzalu during this talk, just by being connected to the WiFi.
            </p>

            <h4>What this proves:</h4>
            <ul>
                <li>‚úÖ You were at Zanzalu (Venue ID: 2407) during this ZK talk.</li>
                <li>‚úÖ You were connected to the "Aura Space" WiFi network.</li>
                <li>‚úÖ Your device is authentic and generated a unique proof.</li>
                <li>‚úÖ The proof is single-use and cannot be copied (thanks to a unique nullifier).</li>
            </ul>

            <h4>What remains private:</h4>
            <ul>
                <li>üîí Your device's unique identity (your secret is never revealed).</li>
                <li>üîí The exact time you generated the proof.</li>
                <li>üîí Any other places you've been or networks you've connected to.</li>
                <li>üîí Any of your personal information.</li>
            </ul>

            <h4 style="margin-top: 20px;">Technical Details:</h4>
            <div class="code-block">Circuit: 36 ACIR Opcodes (extremely lightweight!)
Proving System: Noir + Barretenberg
Hash Function: Pedersen (ZK-friendly)
Proof Size: ~2KB
Verification Time: ~10ms</div>
        </div>
    </div>

    <script>
        // Tab functionality
        function openTab(evt, tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-link').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            evt.currentTarget.classList.add('active');
        }

        // Helper function to create a simple hash from a string
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash &= hash; // Convert to 32bit integer
            }
            // Return a positive BigInt-like string
            return Math.abs(hash).toString();
        }

        // --- Main Application Logic ---

        // Initialize the form with dynamic, real-world data
        function initializeDemoData() {
            // 1. Generate or retrieve user secret - FIXED: Generate pure numeric string
            let userSecret = localStorage.getItem('zanzaluUserSecret');
            if (!userSecret) {
                // Create a large random integer as a pure numeric string (16-20 digits)
                // This ensures it's a valid Field element for Noir without any letters or dashes
                const randomBytes = new Uint8Array(8);
                crypto.getRandomValues(randomBytes);
                
                // Convert bytes to a big integer string
                let bigInt = 0n;
                for (let i = 0; i < randomBytes.length; i++) {
                    bigInt = (bigInt << 8n) + BigInt(randomBytes[i]);
                }
                
                // Ensure it's a reasonable size (not too big for Field arithmetic)
                userSecret = (bigInt % 999999999999999999n + 100000000000000000n).toString();
                localStorage.setItem('zanzaluUserSecret', userSecret);
            }
            document.getElementById('userSecret').value = userSecret;

            // 2. Generate a new random nonce for this session
            document.getElementById('connectionNonce').value = Math.floor(Math.random() * 1000000);

            // 3. Hash the WiFi network name
            const networkName = document.getElementById('networkSsid').value;
            document.getElementById('networkSsidHash').value = simpleHash(networkName);

            // 4. Set up live time window for the talk
            const now = new Date();
            // Pretend the talk started 15 minutes ago and ends in 45 minutes
            const talkStart = new Date(now.getTime() - 15 * 60 * 1000);
            const talkEnd = new Date(now.getTime() + 45 * 60 * 1000);
            
            // Proof timestamp is the exact moment of generation
            const proofTimestamp = now;

            document.getElementById('timeWindowStart').value = Math.floor(talkStart.getTime() / 1000);
            document.getElementById('timeWindowEnd').value = Math.floor(talkEnd.getTime() / 1000);
            document.getElementById('proofTimestamp').value = Math.floor(proofTimestamp.getTime() / 1000);

            // Display human-readable times for clarity
            const formatToEAT = (date) => date.toLocaleTimeString('en-US', { timeZone: 'Africa/Nairobi', hour12: false }) + ' EAT';
            document.querySelector('[for="timeWindowStart"] + input + small').textContent = `Talk started at ${formatToEAT(talkStart)}`;
            document.querySelector('[for="timeWindowEnd"] + input + small').textContent = `Talk ends at ${formatToEAT(talkEnd)}`;
            document.querySelector('[for="proofTimestamp"] + input + small').textContent = `Proof generated at ${formatToEAT(proofTimestamp)}`;
        }
        
        // Generate proof using backend API
        async function generateProofViaAPI(formData) {
            // The backend API is always on localhost:3001 for this demo
            const apiUrl = 'http://localhost:3001/api/generate-proof';
            
            console.log('Making API request to:', apiUrl);
            console.log('Request data:', formData);
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData)
            });
            
            if (!response.ok) {
                const responseText = await response.text();
                console.error('API Error Response:', responseText);
                try {
                    // Try to parse as JSON, but fall back to text
                    const errorData = JSON.parse(responseText);
                    throw new Error(errorData.error || `Server returned status ${response.status}`);
                } catch (jsonError) {
                    throw new Error(`Server returned non-JSON response (${response.status}): ${responseText.substring(0, 200)}...`);
                }
            }
            
            const responseText = await response.text();
            try {
                return JSON.parse(responseText);
            } catch (jsonError) {
                console.error('JSON Parse Error:', jsonError);
                console.error('Response Text:', responseText);
                throw new Error(`Server returned invalid JSON: ${responseText.substring(0, 200)}...`);
            }
        }

        // --- Event Listeners ---
        
        // Generate proof button
        document.getElementById('generateBtn').addEventListener('click', async function() {
            // Re-initialize data on each click to get fresh nonce and timestamps
            initializeDemoData();

            const generateBtn = this;
            const statusDiv = document.getElementById('status');
            const outputDiv = document.getElementById('output');
            
            // Disable button and show loading
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating Proof...';
            
            statusDiv.style.display = 'block';
            statusDiv.className = 'status info';
            statusDiv.textContent = 'Generating Zero-Knowledge proof... This may take a moment.';
            
            try {
                // Collect form data
                const formData = {
                    userSecret: document.getElementById('userSecret').value,
                    connectionNonce: document.getElementById('connectionNonce').value,
                    venueId: document.getElementById('venueId').value,
                    networkSsidHash: document.getElementById('networkSsidHash').value,
                    eventId: document.getElementById('eventId').value,
                    timeWindowStart: document.getElementById('timeWindowStart').value,
                    timeWindowEnd: document.getElementById('timeWindowEnd').value,
                    proofTimestamp: document.getElementById('proofTimestamp').value
                };

                // Validate time window
                const startTime = parseInt(formData.timeWindowStart);
                const endTime = parseInt(formData.timeWindowEnd);
                const proofTime = parseInt(formData.proofTimestamp);
                
                if (proofTime < startTime || proofTime > endTime) {
                    throw new Error('Proof timestamp must be within the valid time window');
                }

                // Generate proof using actual Noir backend
                const result = await generateProofViaAPI(formData);
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to generate proof');
                }
                
                // Show success
                statusDiv.className = 'status success';
                statusDiv.textContent = '‚úÖ Proof generated successfully!';
                
                // Display results
                outputDiv.style.display = 'block';
                outputDiv.innerHTML = `
                    <h4>üéâ Zero-Knowledge Proof Generated!</h4>
                    
                    <h5>Generated Public Inputs (Verifier.toml):</h5>
                    <div class="code-block">${result.proverToml}</div>
                    
                    <h5>Noir Compilation Output:</h5>
                    <div class="code-block">${result.compileOutput || 'Compilation successful'}</div>
                    
                    <h5>Noir Execution Output:</h5>
                    <div class="code-block">${result.executionOutput}</div>
                    
                    <h5>üî• Barretenberg Cryptographic Proof:</h5>
                    <div class="code-block">Real ZK Proof Generated: ${result.proofGenerated ? '‚úÖ YES' : '‚ùå NO'}
${window.location.hostname !== 'localhost' ? '\n‚ö†Ô∏è Production Mode: Simulated proof (full Noir compilation requires local environment)' : ''}

Proof Data: ${result.proofData}
Public Inputs: ${result.publicInputs}
Verification Key: ${result.verificationKey}

Circuit Outputs:
  Venue ID: ${result.circuitOutputs.venue_id}
  Network Hash: ${result.circuitOutputs.network_hash}
  Proof Timestamp: ${result.circuitOutputs.proof_timestamp}

Proof Hash: ${result.proofHash}
Nullifier: ${result.nullifier}
User Commitment: ${result.userCommitment}

Timestamp: ${result.timestamp}</div>
                    
                    <p><strong>What this proves:</strong></p>
                    <ul>
                        <li>‚úÖ You were at venue ${formData.venueId} during the valid time window</li>
                        <li>‚úÖ You connected to network hash ${formData.networkSsidHash}</li>
                        <li>‚úÖ Your device is authentic (has valid secret)</li>
                        <li>‚úÖ This proof cannot be reused or copied (nullifier: ${result.nullifier.substring(0, 10)}...)</li>
                    </ul>
                `;
                
                // Store proof hash for this session only
                sessionStorage.setItem('lastGeneratedProofHash', result.proofHash);
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `‚ùå Error: ${error.message}`;
            }
            
            // Re-enable button
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate ZK Proof';
        });

        function displayProofGenerationResult(result) {
            hideLoading();
            const resultDiv = document.getElementById('proofResult');
            resultDiv.style.display = 'block';

            document.getElementById('proofStatus').textContent = result.message;

            if (result.success) {
                document.getElementById('proofHash').textContent = result.proofHash;
                document.getElementById('publicOutputs').textContent = JSON.stringify(result.publicOutputs, null, 2);
                document.getElementById('generationTimestamp').textContent = new Date(result.timestamp).toLocaleString();
                
                // Show verification section and pre-fill the hash
                document.getElementById('verificationSection').style.display = 'block';
                const proofHashInput = document.getElementById('proofHashToVerify');
                proofHashInput.value = result.proofHash;
                
                // Store proof data in session storage for verification
                const key = result.proofHash;
                const value = JSON.stringify({
                    publicOutputs: result.publicOutputs,
                    timestamp: result.timestamp,
                    proofHash: result.proofHash // Storing hash for completeness
                });
                
                console.log(`Storing proof data in sessionStorage. Key: ${key}`);
                sessionStorage.setItem(key, value);

                // Scroll to the results
                document.getElementById('proofResult').scrollIntoView({ behavior: 'smooth' });
            } else {
                document.getElementById('proofHash').textContent = 'N/A';
                document.getElementById('publicOutputs').textContent = `Error: ${result.error}\nDetails: ${result.details || ''}`;
                document.getElementById('generationTimestamp').textContent = 'N/A';
            }
        }

        async function verifyProof() {
            const verifyBtn = document.getElementById('verifyBtn');
            verifyBtn.disabled = true;
            verifyBtn.textContent = 'Verifying...';
            const resultDiv = document.getElementById('verificationResult');
            resultDiv.innerHTML = '<p>üîç Verifying proof with backend...</p>';

            const proofHashToVerify = document.getElementById('proofHash').value;
            console.log(`Attempting to verify. Reading hash from input: ${proofHashToVerify}`);
            
            if (!proofHashToVerify) {
                resultDiv.innerHTML = '<p class="error-msg">‚ùå Error: Please generate a proof first to get a hash to verify.</p>';
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'Verify Proof';
                return;
            }
            
            // This is the key part: retrieve the original proof generation data from sessionStorage
            const storedDataJSON = sessionStorage.getItem(proofHashToVerify);
            console.log(`Retrieved from sessionStorage: ${storedDataJSON}`);
            let storedProofData = null;
            if (storedDataJSON) {
                try {
                    storedProofData = JSON.parse(storedDataJSON);
                } catch(e) {
                    console.error("Error parsing data from sessionStorage", e);
                }
            }

            try {
                const response = await fetch('/api/verify-proof', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ proofHash: proofHashToVerify })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `Server responded with status: ${response.status}`);
                }
                
                // THIS IS THE CRITICAL CHECK that prevents the error.
                if (!storedProofData) {
                     resultDiv.innerHTML = `
                        <h4>Verification Result</h4>
                        <p><strong>Backend Status:</strong> ${result.verified ? '‚úÖ Verified' : '‚ùå Failed'}</p>
                        <p class="error-msg"><strong>Frontend Warning:</strong> Could not find original proof generation data in this browser session. This can happen if you refresh the page or open a new tab.</p>
                        <p><strong>Proof Hash:</strong> <code>${proofHashToVerify}</code></p>
                        <hr>
                        <details>
                            <summary>Raw Backend Verification Output</summary>
                            <pre><code>${JSON.stringify(result, null, 2)}</code></pre>
                        </details>
                     `;
                     return;
                }

                const verificationHtml = `
                    <h4>Verification Result</h4>
                    <p><strong>Status:</strong> ${result.verified ? '‚úÖ Verified' : '‚ùå Failed'}</p>
                    <p><strong>Proof Hash:</strong> <code>${proofHashToVerify}</code></p>
                    <p><strong>Backend Verification Time:</strong> ${new Date(result.timestamp).toLocaleString()}</p>
                    <p><strong>Original Proof Generation Time:</strong> ${new Date(storedProofData.timestamp).toLocaleString()}</p>
                    <hr>
                    <details>
                        <summary>Raw Verification Output</summary>
                        <pre><code>${JSON.stringify(result, null, 2)}</code></pre>
                    </details>
                `;
                resultDiv.innerHTML = verificationHtml;

            } catch (error) {
                console.error('Verification error:', error);
                resultDiv.innerHTML = `<p class="error-msg">‚ùå Verification error: ${error.message}</p>`;
            } finally {
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'Verify Proof';
            }
        }

        // QR Scanner Variables
        let currentStream = null;
        let qrScanner = null;
        let scannedVenueData = null;

        // QR Scanner Functions
        async function startQRScanner() {
            try {
                showScanStatus('üé• Starting camera...', 'warning');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                
                const video = document.getElementById('videoPreview');
                video.srcObject = stream;
                video.style.display = 'block';
                video.play();
                
                currentStream = stream;
                
                document.getElementById('startScanBtn').disabled = true;
                document.getElementById('stopScanBtn').disabled = false;
                
                // Start scanning for QR codes
                qrScanner = setInterval(() => {
                    scanForQRCode(video);
                }, 500);
                
                showScanStatus('üì∏ Camera ready! Point at venue QR code to scan', 'success');
                
            } catch (error) {
                console.error('Camera access error:', error);
                showScanStatus('‚ùå Camera access denied. Please allow camera access and try again.', 'error');
            }
        }

        function stopQRScanner() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                currentStream = null;
            }
            
            if (qrScanner) {
                clearInterval(qrScanner);
                qrScanner = null;
            }
            
            const video = document.getElementById('videoPreview');
            video.style.display = 'none';
            video.srcObject = null;
            
            document.getElementById('startScanBtn').disabled = false;
            document.getElementById('stopScanBtn').disabled = true;
            
            showScanStatus('üì∑ Camera stopped', 'warning');
        }

        function scanForQRCode(video) {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const canvas = document.getElementById('qrCanvas');
                const context = canvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                
                if (typeof jsQR !== 'undefined') {
                    const qrCode = jsQR(imageData.data, imageData.width, imageData.height);
                    
                    if (qrCode) {
                        console.log('üì± QR Code detected:', qrCode.data);
                        processQRCode(qrCode.data);
                        stopQRScanner();
                    }
                }
            }
        }

        // QR Code Processing
        async function processQRCode(qrData) {
            try {
                showScanStatus('üîç Processing QR code...', 'warning');
                
                // Parse QR code data
                const venueData = JSON.parse(qrData);
                console.log('üìã Parsed venue data:', venueData);
                
                // Verify the signature
                const isValid = await verifyVenueSignature(venueData);
                
                if (!isValid) {
                    showScanStatus('‚ùå Invalid venue QR code! This may be a fake or tampered QR code.', 'error');
                    return;
                }
                
                // Store verified data
                scannedVenueData = venueData;
                
                // Display venue information
                displayScannedVenueData(venueData);
                
                showScanStatus('‚úÖ Venue QR code verified! Proceed to generate your privacy proof.', 'success');
                
            } catch (error) {
                console.error('QR processing error:', error);
                showScanStatus('‚ùå Invalid QR code format. Please scan a valid venue QR code.', 'error');
            }
        }

        // Signature Verification
        async function verifyVenueSignature(venueData) {
            try {
                if (!venueData.signature || !venueData.public_key) {
                    console.error('Missing signature or public key');
                    return false;
                }

                // Reconstruct the original message that was signed
                const originalMessage = {
                    venue_id: venueData.venue_id,
                    wifi_name: venueData.wifi_name,
                    network_hash: venueData.network_hash,
                    event_id: venueData.event_id,
                    time_window_start: venueData.time_window_start,
                    time_window_end: venueData.time_window_end
                };

                const messageToVerify = JSON.stringify(originalMessage);
                console.log('üîç Verifying message:', messageToVerify);

                // Import the public key
                const publicKey = await crypto.subtle.importKey(
                    'jwk',
                    venueData.public_key,
                    { name: 'ECDSA', namedCurve: 'P-256' },
                    false,
                    ['verify']
                );

                // Convert hex signature to ArrayBuffer
                const signatureBytes = new Uint8Array(
                    venueData.signature.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
                );

                // Verify the signature
                const isValid = await crypto.subtle.verify(
                    { name: 'ECDSA', hash: 'SHA-256' },
                    publicKey,
                    signatureBytes,
                    new TextEncoder().encode(messageToVerify)
                );

                console.log('üîê Signature verification result:', isValid);
                return isValid;

            } catch (error) {
                console.error('Signature verification error:', error);
                return false;
            }
        }

        // Display scanned venue data
        function displayScannedVenueData(data) {
            document.getElementById('scannedVenueName').textContent = data.venue_name || 'Unknown Venue';
            document.getElementById('scannedWifiName').textContent = data.wifi_name;
            document.getElementById('scannedEventId').textContent = data.event_id;
            
            // Format time window
            const startTime = new Date(data.time_window_start * 1000).toLocaleString();
            const endTime = new Date(data.time_window_end * 1000).toLocaleString();
            document.getElementById('scannedTimeWindow').textContent = `${startTime} - ${endTime}`;
            
            // Show the venue info section
            document.getElementById('scannedVenueInfo').style.display = 'block';
        }

        // Proceed to proof generation with scanned data
        function proceedToProofGeneration() {
            if (!scannedVenueData) {
                alert('No venue data available. Please scan a QR code first.');
                return;
            }
            
            // Update form fields with scanned data
            document.getElementById('venueId').value = scannedVenueData.venue_id;
            document.getElementById('networkSsid').value = scannedVenueData.wifi_name;
            document.getElementById('networkSsidHash').value = scannedVenueData.network_hash;
            document.getElementById('eventId').value = scannedVenueData.event_id;
            document.getElementById('timeWindowStart').value = scannedVenueData.time_window_start;
            document.getElementById('timeWindowEnd').value = scannedVenueData.time_window_end;
            
            // Switch to generate tab
            openTab({ currentTarget: document.querySelector('.tab-link[onclick*="generate"]') }, 'generate');
            
            // Re-initialize data to get fresh user secret and nonce
            initializeDemoData();
        }

        // Test function with mock data
        function useTestQR() {
            const testQRData = {
                "venue_name": "Demo Coffee Shop",
                "venue_id": 67890,
                "wifi_name": "coffee_shop_guest",
                "network_hash": "5268232a3bb43db43fd721461da03b6230c08e964b4e6d73b8d617613f58e7e0",
                "event_id": 20241215,
                "time_window_start": Math.floor(Date.now() / 1000) - 3600,
                "time_window_end": Math.floor(Date.now() / 1000) + 3600,
                "signature": "fef4385a027b5711fce1e67b0d19a9278c47823a3e9efdc2f24d98c9014c4234af9c607b6fc4d927382061ed2c275773698603fa98687820ff36227929a3ca3a",
                "public_key": {
                    "crv": "P-256",
                    "ext": true,
                    "key_ops": ["verify"],
                    "kty": "EC",
                    "x": "l35LM0TzK0diAIeKWKkHEtAV01U1z_wg2f0MpObj4xQ",
                    "y": "H0JqTGawJxNl0tekSoR4H72yj33rATw0oky9-zzovGw"
                },
                "generated_at": Math.floor(Date.now() / 1000),
                "crypto_type": "WebCrypto-ECDSA-P256"
            };
            
            showScanStatus('üß™ Using test QR data...', 'warning');
            processQRCode(JSON.stringify(testQRData));
        }

        // Show scan status messages
        function showScanStatus(message, type) {
            const statusDiv = document.getElementById('scanStatus');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 5000);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeDemoData();
            console.log('WiFiProof App Initialized with QR Scanner');
        });
    </script>
</body>
</html>