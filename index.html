<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proof of Zanzalu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 700;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 40px;
            font-size: 1.1em;
        }

        .form-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 4px solid #667eea;
        }

        .form-section h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .input-group input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group .help-text {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin: 10px 0;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #9fcdff;
        }

        .proof-output {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .code-block {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Monaco', monospace;
            font-size: 0.9em;
            margin: 10px 0;
            overflow-x: auto;
            border: 1px solid #333;
            white-space: pre-wrap;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #eee;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üì∂ Zanzalu Presence Proof</h1>
            <p>Generate a ZK proof to cryptographically verify you attended Zanzalu!</p>
        </header>

        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'generate')">Generate Proof</button>
            <button class="tab-link" onclick="openTab(event, 'verify')">Verify Proof</button>
            <button class="tab-link" onclick="openTab(event, 'about')">About</button>
        </div>

        <div id="generate" class="tab-content active">
            <h3>üîê Device Identity (Private)</h3>
            <p>Your device generates a private secret, which is never shared. It remains in your browser's local storage.</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="userSecret">User Secret</label>
                    <input type="text" id="userSecret" placeholder="e.g., 1234567890123456" readonly>
                    <small>A unique numeric secret, automatically generated and stored only in this browser.</small>
                </div>
                <div class="form-group">
                    <label for="connectionNonce">Connection Nonce</label>
                    <input type="text" id="connectionNonce" placeholder="e.g., 98765" readonly>
                    <small>A random number for this specific proof, generated each time you click.</small>
                </div>
            </div>

            <h3>Venue Information (Public)</h3>
            <p>This information is public and proves you were at the right place.</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="venueId">Venue ID</label>
                    <input type="text" id="venueId" value="2407" readonly>
                    <small>The official ID for Zanzalu, July 2024.</small>
                </div>
                <div class="form-group">
                    <label for="networkSsid">WiFi Network Name</label>
                    <input type="text" id="networkSsid" value="Aura Space" readonly>
                    <small>The name of the WiFi network at the coworking space.</small>
                </div>
                <div class="form-group" style="display: none;">
                    <label for="networkSsidHash">Network SSID Hash</label>
                    <input type="text" id="networkSsidHash" placeholder="Auto-generated from WiFi Name" readonly>
                    <small>The cryptographic hash of the network name, used in the proof.</small>
                </div>
            </div>

            <h3>‚è∞ Time Window (Public)</h3>
            <p>This proves you were here at the right time‚Äîduring this talk!</p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="timeWindowStart">Talk Start Time (Unix Timestamp)</label>
                    <input type= "text" id="timeWindowStart" readonly>
                    <small>The time this ZK talk started (in EAT).</small>
                </div>
                <div class="form-group">
                    <label for="timeWindowEnd">Talk End Time (Unix Timestamp)</label>
                    <input type="text" id="timeWindowEnd" readonly>
                    <small>The time this ZK talk is scheduled to end (in EAT).</small>
                </div>
                <div class="form-group">
                    <label for="proofTimestamp">Your Proof Generation Time (Unix Timestamp)</label>
                    <input type="text" id="proofTimestamp" readonly>
                    <small>The exact time you click the generate button (in EAT).</small>
                </div>
            </div>

            <button id="generateBtn" class="button-primary">Generate Zanzalu Proof</button>
            
            <div id="status" class="status" style="display:none;"></div>
            <div id="output" class="output" style="display:none;"></div>
        </div>

        <div id="verify" class="tab-content">
            <h3>‚úÖ Verify a Zanzalu Proof</h3>
            <div class="form-group">
                <label for="proofHash">Proof Hash</label>
                <input type="text" id="proofHash" placeholder="Paste the proof hash you want to verify">
            </div>
            <button id="verifyBtn" onclick="verifyProof()" class="button-primary">Verify Proof</button>
            <div id="verifyStatus" class="status" style="display:none;"></div>
            <div id="verificationResult" class="result-box" style="margin-top: 1rem;">
                <!-- Verification result will be displayed here -->
            </div>
        </div>

        <div id="about" class="tab-content">
            <h3>üéØ What is Zanzalu Presence Proof?</h3>
            <p>
                This is a live demo of a privacy-preserving Zero-Knowledge proof system. It lets you prove you were physically present
                at the "Aura Space" coworking area in Zanzalu during this talk, just by being connected to the WiFi.
            </p>

            <h4>What this proves:</h4>
            <ul>
                <li>‚úÖ You were at Zanzalu (Venue ID: 2407) during this ZK talk.</li>
                <li>‚úÖ You were connected to the "Aura Space" WiFi network.</li>
                <li>‚úÖ Your device is authentic and generated a unique proof.</li>
                <li>‚úÖ The proof is single-use and cannot be copied (thanks to a unique nullifier).</li>
            </ul>

            <h4>What remains private:</h4>
            <ul>
                <li>üîí Your device's unique identity (your secret is never revealed).</li>
                <li>üîí The exact time you generated the proof.</li>
                <li>üîí Any other places you've been or networks you've connected to.</li>
                <li>üîí Any of your personal information.</li>
            </ul>

            <h4 style="margin-top: 20px;">Technical Details:</h4>
            <div class="code-block">Circuit: 36 ACIR Opcodes (extremely lightweight!)
Proving System: Noir + Barretenberg
Hash Function: Pedersen (ZK-friendly)
Proof Size: ~2KB
Verification Time: ~10ms</div>
        </div>
    </div>

    <script>
        // Tab functionality
        function openTab(evt, tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-link').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            evt.currentTarget.classList.add('active');
        }

        // Helper function to create a simple hash from a string
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = (hash << 5) - hash + char;
                hash &= hash; // Convert to 32bit integer
            }
            // Return a positive BigInt-like string
            return Math.abs(hash).toString();
        }

        // --- Main Application Logic ---

        // Initialize the form with dynamic, real-world data
        function initializeDemoData() {
            // 1. Generate or retrieve user secret - FIXED: Generate pure numeric string
            let userSecret = localStorage.getItem('zanzaluUserSecret');
            if (!userSecret) {
                // Create a large random integer as a pure numeric string (16-20 digits)
                // This ensures it's a valid Field element for Noir without any letters or dashes
                const randomBytes = new Uint8Array(8);
                crypto.getRandomValues(randomBytes);
                
                // Convert bytes to a big integer string
                let bigInt = 0n;
                for (let i = 0; i < randomBytes.length; i++) {
                    bigInt = (bigInt << 8n) + BigInt(randomBytes[i]);
                }
                
                // Ensure it's a reasonable size (not too big for Field arithmetic)
                userSecret = (bigInt % 999999999999999999n + 100000000000000000n).toString();
                localStorage.setItem('zanzaluUserSecret', userSecret);
            }
            document.getElementById('userSecret').value = userSecret;

            // 2. Generate a new random nonce for this session
            document.getElementById('connectionNonce').value = Math.floor(Math.random() * 1000000);

            // 3. Hash the WiFi network name
            const networkName = document.getElementById('networkSsid').value;
            document.getElementById('networkSsidHash').value = simpleHash(networkName);

            // 4. Set up live time window for the talk
            const now = new Date();
            // Pretend the talk started 15 minutes ago and ends in 45 minutes
            const talkStart = new Date(now.getTime() - 15 * 60 * 1000);
            const talkEnd = new Date(now.getTime() + 45 * 60 * 1000);
            
            // Proof timestamp is the exact moment of generation
            const proofTimestamp = now;

            document.getElementById('timeWindowStart').value = Math.floor(talkStart.getTime() / 1000);
            document.getElementById('timeWindowEnd').value = Math.floor(talkEnd.getTime() / 1000);
            document.getElementById('proofTimestamp').value = Math.floor(proofTimestamp.getTime() / 1000);

            // Display human-readable times for clarity
            const formatToEAT = (date) => date.toLocaleTimeString('en-US', { timeZone: 'Africa/Nairobi', hour12: false }) + ' EAT';
            document.querySelector('[for="timeWindowStart"] + input + small').textContent = `Talk started at ${formatToEAT(talkStart)}`;
            document.querySelector('[for="timeWindowEnd"] + input + small').textContent = `Talk ends at ${formatToEAT(talkEnd)}`;
            document.querySelector('[for="proofTimestamp"] + input + small').textContent = `Proof generated at ${formatToEAT(proofTimestamp)}`;
        }
        
        // Generate proof using backend API
        async function generateProofViaAPI(formData) {
            // The backend API is always on localhost:3001 for this demo
            const apiUrl = 'http://localhost:3001/api/generate-proof';
            
            console.log('Making API request to:', apiUrl);
            console.log('Request data:', formData);
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData)
            });
            
            if (!response.ok) {
                const responseText = await response.text();
                console.error('API Error Response:', responseText);
                try {
                    // Try to parse as JSON, but fall back to text
                    const errorData = JSON.parse(responseText);
                    throw new Error(errorData.error || `Server returned status ${response.status}`);
                } catch (jsonError) {
                    throw new Error(`Server returned non-JSON response (${response.status}): ${responseText.substring(0, 200)}...`);
                }
            }
            
            const responseText = await response.text();
            try {
                return JSON.parse(responseText);
            } catch (jsonError) {
                console.error('JSON Parse Error:', jsonError);
                console.error('Response Text:', responseText);
                throw new Error(`Server returned invalid JSON: ${responseText.substring(0, 200)}...`);
            }
        }

        // --- Event Listeners ---
        
        // Generate proof button
        document.getElementById('generateBtn').addEventListener('click', async function() {
            // Re-initialize data on each click to get fresh nonce and timestamps
            initializeDemoData();

            const generateBtn = this;
            const statusDiv = document.getElementById('status');
            const outputDiv = document.getElementById('output');
            
            // Disable button and show loading
            generateBtn.disabled = true;
            generateBtn.textContent = 'Generating Proof...';
            
            statusDiv.style.display = 'block';
            statusDiv.className = 'status info';
            statusDiv.textContent = 'Generating Zero-Knowledge proof... This may take a moment.';
            
            try {
                // Collect form data
                const formData = {
                    userSecret: document.getElementById('userSecret').value,
                    connectionNonce: document.getElementById('connectionNonce').value,
                    venueId: document.getElementById('venueId').value,
                    networkSsidHash: document.getElementById('networkSsidHash').value,
                    timeWindowStart: document.getElementById('timeWindowStart').value,
                    timeWindowEnd: document.getElementById('timeWindowEnd').value,
                    proofTimestamp: document.getElementById('proofTimestamp').value
                };

                // Validate time window
                const startTime = parseInt(formData.timeWindowStart);
                const endTime = parseInt(formData.timeWindowEnd);
                const proofTime = parseInt(formData.proofTimestamp);
                
                if (proofTime < startTime || proofTime > endTime) {
                    throw new Error('Proof timestamp must be within the valid time window');
                }

                // Generate proof using actual Noir backend
                const result = await generateProofViaAPI(formData);
                
                if (!result.success) {
                    throw new Error(result.error || 'Failed to generate proof');
                }
                
                // Show success
                statusDiv.className = 'status success';
                statusDiv.textContent = '‚úÖ Proof generated successfully!';
                
                // Display results
                outputDiv.style.display = 'block';
                outputDiv.innerHTML = `
                    <h4>üéâ Zero-Knowledge Proof Generated!</h4>
                    
                    <h5>Generated Public Inputs (Verifier.toml):</h5>
                    <div class="code-block">${result.proverToml}</div>
                    
                    <h5>Noir Compilation Output:</h5>
                    <div class="code-block">${result.compileOutput || 'Compilation successful'}</div>
                    
                    <h5>Noir Execution Output:</h5>
                    <div class="code-block">${result.executionOutput}</div>
                    
                    <h5>üî• Barretenberg Cryptographic Proof:</h5>
                    <div class="code-block">Real ZK Proof Generated: ${result.proofGenerated ? '‚úÖ YES' : '‚ùå NO'}
${window.location.hostname !== 'localhost' ? '\n‚ö†Ô∏è Production Mode: Simulated proof (full Noir compilation requires local environment)' : ''}

Proof Data: ${result.proofData}
Public Inputs: ${result.publicInputs}
Verification Key: ${result.verificationKey}

Circuit Outputs:
  Venue ID: ${result.circuitOutputs.venue_id}
  Network Hash: ${result.circuitOutputs.network_hash}
  Proof Timestamp: ${result.circuitOutputs.proof_timestamp}

Proof Hash: ${result.proofHash}
Nullifier: ${result.nullifier}
User Commitment: ${result.userCommitment}

Timestamp: ${result.timestamp}</div>
                    
                    <p><strong>What this proves:</strong></p>
                    <ul>
                        <li>‚úÖ You were at venue ${formData.venueId} during the valid time window</li>
                        <li>‚úÖ You connected to network hash ${formData.networkSsidHash}</li>
                        <li>‚úÖ Your device is authentic (has valid secret)</li>
                        <li>‚úÖ This proof cannot be reused or copied (nullifier: ${result.nullifier.substring(0, 10)}...)</li>
                    </ul>
                `;
                
                // Store proof hash for this session only
                sessionStorage.setItem('lastGeneratedProofHash', result.proofHash);
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `‚ùå Error: ${error.message}`;
            }
            
            // Re-enable button
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generate ZK Proof';
        });

        function displayProofGenerationResult(result) {
            hideLoading();
            const resultDiv = document.getElementById('proofResult');
            resultDiv.style.display = 'block';

            document.getElementById('proofStatus').textContent = result.message;

            if (result.success) {
                document.getElementById('proofHash').textContent = result.proofHash;
                document.getElementById('publicOutputs').textContent = JSON.stringify(result.publicOutputs, null, 2);
                document.getElementById('generationTimestamp').textContent = new Date(result.timestamp).toLocaleString();
                
                // Show verification section and pre-fill the hash
                document.getElementById('verificationSection').style.display = 'block';
                const proofHashInput = document.getElementById('proofHashToVerify');
                proofHashInput.value = result.proofHash;
                
                // Store proof data in session storage for verification
                const key = result.proofHash;
                const value = JSON.stringify({
                    publicOutputs: result.publicOutputs,
                    timestamp: result.timestamp,
                    proofHash: result.proofHash // Storing hash for completeness
                });
                
                console.log(`Storing proof data in sessionStorage. Key: ${key}`);
                sessionStorage.setItem(key, value);

                // Scroll to the results
                document.getElementById('proofResult').scrollIntoView({ behavior: 'smooth' });
            } else {
                document.getElementById('proofHash').textContent = 'N/A';
                document.getElementById('publicOutputs').textContent = `Error: ${result.error}\nDetails: ${result.details || ''}`;
                document.getElementById('generationTimestamp').textContent = 'N/A';
            }
        }

        async function verifyProof() {
            const verifyBtn = document.getElementById('verifyBtn');
            verifyBtn.disabled = true;
            verifyBtn.textContent = 'Verifying...';
            const resultDiv = document.getElementById('verificationResult');
            resultDiv.innerHTML = '<p>üîç Verifying proof with backend...</p>';

            const proofHashToVerify = document.getElementById('proofHash').value;
            console.log(`Attempting to verify. Reading hash from input: ${proofHashToVerify}`);
            
            if (!proofHashToVerify) {
                resultDiv.innerHTML = '<p class="error-msg">‚ùå Error: Please generate a proof first to get a hash to verify.</p>';
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'Verify Proof';
                return;
            }
            
            // This is the key part: retrieve the original proof generation data from sessionStorage
            const storedDataJSON = sessionStorage.getItem(proofHashToVerify);
            console.log(`Retrieved from sessionStorage: ${storedDataJSON}`);
            let storedProofData = null;
            if (storedDataJSON) {
                try {
                    storedProofData = JSON.parse(storedDataJSON);
                } catch(e) {
                    console.error("Error parsing data from sessionStorage", e);
                }
            }

            try {
                const response = await fetch('/api/verify-proof', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ proofHash: proofHashToVerify })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `Server responded with status: ${response.status}`);
                }
                
                // THIS IS THE CRITICAL CHECK that prevents the error.
                if (!storedProofData) {
                     resultDiv.innerHTML = `
                        <h4>Verification Result</h4>
                        <p><strong>Backend Status:</strong> ${result.verified ? '‚úÖ Verified' : '‚ùå Failed'}</p>
                        <p class="error-msg"><strong>Frontend Warning:</strong> Could not find original proof generation data in this browser session. This can happen if you refresh the page or open a new tab.</p>
                        <p><strong>Proof Hash:</strong> <code>${proofHashToVerify}</code></p>
                        <hr>
                        <details>
                            <summary>Raw Backend Verification Output</summary>
                            <pre><code>${JSON.stringify(result, null, 2)}</code></pre>
                        </details>
                     `;
                     return;
                }

                const verificationHtml = `
                    <h4>Verification Result</h4>
                    <p><strong>Status:</strong> ${result.verified ? '‚úÖ Verified' : '‚ùå Failed'}</p>
                    <p><strong>Proof Hash:</strong> <code>${proofHashToVerify}</code></p>
                    <p><strong>Backend Verification Time:</strong> ${new Date(result.timestamp).toLocaleString()}</p>
                    <p><strong>Original Proof Generation Time:</strong> ${new Date(storedProofData.timestamp).toLocaleString()}</p>
                    <hr>
                    <details>
                        <summary>Raw Verification Output</summary>
                        <pre><code>${JSON.stringify(result, null, 2)}</code></pre>
                    </details>
                `;
                resultDiv.innerHTML = verificationHtml;

            } catch (error) {
                console.error('Verification error:', error);
                resultDiv.innerHTML = `<p class="error-msg">‚ùå Verification error: ${error.message}</p>`;
            } finally {
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'Verify Proof';
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeDemoData();
            console.log('Zanzalu Presence Proof Demo Initialized');
        });
    </script>
</body>
</html>