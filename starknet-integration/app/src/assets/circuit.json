{"noir_version":"1.0.0-beta.5+c651df6e2bf5db3966aa0c95abea2fc4c69d4513","hash":"17214582872226185006","abi":{"parameters":[{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"connection_nonce","type":{"kind":"field"},"visibility":"private"},{"name":"venue_id","type":{"kind":"field"},"visibility":"public"},{"name":"event_id","type":{"kind":"field"},"visibility":"public"},{"name":"nonce_hash","type":{"kind":"field"},"visibility":"public"},{"name":"portal_sig_hash","type":{"kind":"field"},"visibility":"public"},{"name":"time_window_start","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"time_window_end","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"proof_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"7ZjdbtswDIXfxde+kKgfUnmVIijS1hsCBGmRJQOGIu8+SqScdIANzUZ2tRuf0Ja+SNSREvOzexteLt+f98dv7z+6zdNn93LaHw7778+H99fdef9+5LufnckXG7uN7zuLItRtAkvqNrHvgFvEK4e5IXIL6DskEW4B/Ajyo8gNbN9FEHEiXiSIRBEUIZFUBI2IUFAoKBQUCgoFhYJCQaGgUEgoJBQSCgmFhEJCIaGQUEgoJJQklCSUJJQklCSUJJQklCSUJJQkFGuMqlUFVafqVYNqVEVVUk0l29YaVasKkn5XVuZ/qjRVVlNlNVVWU1VUeVZ5VnlWeVZ5VnlWeaA80NQDqDpVL0vhy0747+h/sEygywS6TKDLBFdeh3rEPZ9Pw5DX5O7M45PwY3cajuduc7wcDn33c3e4lEY/PnbHoufdiZ+avhuOb6wM/LY/DPnTtb/1NtNdKVntnMCN3QFa+6NH7Y9kFvQnA9qfII79LX7p76b7R++1fwxuSX+q849Ei/rX5KOZ/P6Z+bOzKoDNdMtAMO2EcCOQX0IArEmwQIvG4G6zcGCWEMKNEGDRLLwbZxECThEszCAIxkFQuLND+oqY8QO4EBUBjtwkwk8jXPR1Ii7eLejfIDC6iiBjlyECrkb41IKYS6cfcwE+LENEV48YiD4sQ2BNJyC49Yg4hZjzN4ZQzYlkl+yQGGm0d6QpAvjVOwTC6h0CcfUOmUW07ZB5RNMOmUc07ZDZdLbtkFlE2w6ZRzTtkHbEoh2ScHSWmf4ldGG1v11c7W+Hq/09i2jz9zyiyd/ziCZ/z6azzd+ziDZztiOWmBMs0WiLu7+qf5jTrzenX29Ov96cfr05/Xpz+vXm9OvNOYtoO3z9en/7x/qbsP49gQRpyt8hPu5dFJK7DQFhcgj0yCFg3eXO2DA1hPjAN3JnYNyfBiffxSI8cgjjD7HjStTkEPySIWw52r3uT1+rw1yHwVLV4mso11iuXH/hBaFyTeWaSzlZuJKTciVGJNdxeEaljpM113FyaTnXcUgKziUmjZPEpdzGcS63lRg0zuU2nkEpt/EwIOSssEaNUWPSOEnsmOd4JzqbDyVW5uUjxjHP5/vM8/k+80K+HzVGjUnjJLFnXuA0e+blA9MzL/B8PfNifs68fBb7kAso17wep/3u5TDkpOa0X46vNcccnn991Ce1Rv9xen8d3i6nIa/HXaGer0/8JgFpW0vy/JVPvOTot7IIT1x6obitZfn8mIceqD7molrPBbNtLRyX/qZHMzbgv9bW2W0tZ+YGfL7EeGsAPRc3ttfsmt8=","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32, T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"use std::hash;\n\n// Enhanced WiFi Connection Proof with Portal Nonce Verification\n// Proves you were at a specific venue during a time window with portal-issued nonce\n\nfn main(\n    // Private inputs (hidden from verifier)\n    user_secret: Field,              // User's private secret which binds proof to user\n    connection_nonce: Field,         // Random nonce for this proof session\n\n    // Public inputs (visible to verifier) - enhanced with portal verification\n    venue_id: pub Field,                 // Unique venue identifier from portal\n    event_id: pub Field,                 // Specific event identifier from portal\n    nonce_hash: pub Field,               // SHA256 hash of portal-issued nonce\n    portal_sig_hash: pub Field,          // SHA256 hash of portal signature\n    time_window_start: pub u64,          // Valid time window start (Unix timestamp)\n    time_window_end: pub u64,            // Valid time window end (Unix timestamp)\n    proof_timestamp: pub u64             // When this proof was generated\n) {\n    // 1. Verify proof timestamp is within valid time window\n    assert(proof_timestamp >= time_window_start);\n    assert(proof_timestamp <= time_window_end);\n\n    // 2. Verify portal nonce and signature hashes are non-zero (valid)\n    assert(nonce_hash != 0);\n    assert(portal_sig_hash != 0);\n\n    // 3. Generate user commitment (proves user has secret without revealing it)\n    let user_commitment = hash::pedersen_hash([\n        user_secret,\n        venue_id,\n        proof_timestamp as Field,\n        connection_nonce\n    ]);\n\n    // 4. Create nullifier to prevent proof reuse (includes portal data for uniqueness)\n    let nullifier = hash::pedersen_hash([\n        user_secret,\n        venue_id,\n        event_id,\n        time_window_start as Field,\n        nonce_hash  // Portal nonce hash ensures uniqueness per portal session\n    ]);\n\n    // 5. Bind proof to portal session (includes portal signature verification)\n    let portal_binding = hash::pedersen_hash([\n        nonce_hash,\n        portal_sig_hash,\n        venue_id,\n        event_id\n    ]);\n\n    // 6. Generate final proof output (this becomes part of the public proof)\n    let proof_output = hash::pedersen_hash([\n        venue_id,\n        event_id,\n        nullifier,\n        user_commitment,\n        portal_binding,\n        proof_timestamp as Field\n    ]);\n    \n    // The proof_output cryptographically demonstrates:\n    // User was at the venue during the time window\n    // User has a valid secret (device binding)\n    // Proof cannot be reused (nullifier)\n    // Portal-issued nonce was included (prevents off-site generation)\n    // Portal signature was verified (prevents forgery)\n    // Without revealing:\n    // User's identity or secret\n    // Exact connection time (only that it was in window)\n    // Other venues visited\n    // Portal nonce or signature values\n\n    std::println(f\"Enhanced Portal WiFi Proof Generated!\");\n    std::println(f\"Venue ID: {venue_id}\");\n    std::println(f\"Event ID: {event_id}\");\n    std::println(f\"Portal Binding: {portal_binding}\");\n    std::println(f\"Proof Output: {proof_output}\");\n}\n\n#[test]\nfn test_portal_wifi_proof() {\n    // Test with portal nonce verification\n    main(\n        12345,         // user_secret\n        99999,         // connection_nonce\n        67890,         // venue_id\n        20241215,      // event_id\n        0x1a2b3c4d5e6f7890abcdef12345678901234567890abcdef123456789, // nonce_hash (SHA256)\n        0x987654321fedcba09876543210000000000000000000000000000000, // portal_sig_hash (SHA256)\n        1640995200,    // time_window_start\n        1640998800,    // time_window_end\n        1640996800     // proof_timestamp\n    );\n}\n","path":"/Users/xiaomao/wifiproof/starknet-integration/circuit/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","directive_integer_quotient","directive_invert"]}